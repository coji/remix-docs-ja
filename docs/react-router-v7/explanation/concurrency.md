---
title: ネットワーク同時実行管理
---

# ネットワーク同時実行管理

[MODES: framework, data]

<br/>
<br/>

Webアプリケーションを構築する際、ネットワークリクエストの管理は困難な作業となることがあります。最新のデータを確保し、同時リクエストを処理するという課題は、中断や競合状態に対処するための複雑なロジックをアプリケーションに生じさせがちです。React Routerは、Webブラウザの直感的な動作を模倣し、それを拡張することで、ネットワーク管理を自動化し、このプロセスを簡素化します。

React Routerが同時実行をどのように処理するかを理解するために、`form`の送信後、React Routerが`loader`から新しいデータをフェッチすることを覚えておくことが重要です。これは再検証（revalidation）と呼ばれます。

## ブラウザの動作との自然な整合性

React Routerのネットワーク同時実行の処理は、Webブラウザがドキュメントを処理する際のデフォルトの動作から強くインスピレーションを受けています。

### リンクナビゲーション

**ブラウザの動作**: ブラウザでリンクをクリックし、ページ遷移が完了する前に別のリンクをクリックすると、ブラウザは最も新しい`action`を優先します。最初の要求をキャンセルし、最後にクリックされたリンクのみに焦点を当てます。

**React Routerの動作**: React Routerはクライアントサイドのナビゲーションを同じ方法で管理します。React Routerアプリケーション内でリンクがクリックされると、ターゲットURLに関連付けられた各`loader`に対してフェッチリクエストを開始します。別のナビゲーションが最初のナビゲーションを中断した場合、React Routerは以前のフェッチリクエストをキャンセルし、最新のリクエストのみが進行するようにします。

### フォーム送信

**ブラウザの動作**: ブラウザでフォーム送信を開始し、その後すぐに別のフォームを再度送信すると、ブラウザは最初の送信を無視し、最新の送信のみを処理します。

**React Routerの動作**: React Routerはフォームを扱う際にこの動作を模倣します。フォームが送信され、最初の送信が完了する前に別の送信が発生した場合、React Routerは元のフェッチリクエストをキャンセルします。その後、最新の送信が完了するのを待ってから、再度ページの再検証をトリガーします。

## 同時送信と再検証

標準的なブラウザはナビゲーションとフォーム送信に対して一度に1つのリクエストに制限されていますが、React Routerはこの動作を向上させます。ナビゲーションとは異なり、[`useFetcher`][use_fetcher]を使用すると、複数のリクエストを同時に実行できます。

React Routerは、サーバー`action`への複数のフォーム送信と、同時再検証リクエストを効率的に処理するように設計されています。新しいデータが利用可能になり次第、状態が迅速に更新されることを保証します。ただし、React Routerは、他の`action`が競合状態を引き起こす場合に、古いデータをコミットしないことで潜在的な落とし穴から保護します。

例えば、3つのフォーム送信が進行中で、1つが完了した場合、React Routerは他の2つを待たずにそのデータでUIを即座に更新し、UIが応答性と動的性を保つようにします。残りの送信が完了すると、React RouterはUIの更新を続け、最新のデータが表示されるようにします。

この凡例を使用します:

- `|`: 送信開始
- ✓: アクション完了、データ再検証開始
- ✅: 再検証されたデータがUIにコミットされる
- ❌: リクエストキャンセル

このシナリオを次の図で視覚化できます:

```text
submission 1: |----✓-----✅
submission 2:    |-----✓-----✅
submission 3:             |-----✓-----✅
```

しかし、後続の送信の再検証が以前の送信よりも早く完了した場合、React Routerは以前のデータを破棄し、UIには最新の情報のみが反映されるようにします:

```text
submission 1: |----✓---------❌
submission 2:    |-----✓-----✅
submission 3:             |-----✓-----✅
```

送信(2)からの再検証が送信(1)よりも遅く開始され、早く完了したため、送信(1)からのリクエストはキャンセルされ、送信(2)からのデータのみがUIにコミットされます。これは後でリクエストされたため、(1)と(2)の両方からの更新された値を含む可能性が高くなります。

## 古いデータの可能性

ユーザーがこれを経験することはまずありませんが、インフラストラクチャが不安定なごくまれな状況では、ユーザーが古いデータを見る可能性がまだあります。React Routerは古いデータのリクエストをキャンセルしますが、それらは最終的にサーバーに到達します。ブラウザでリクエストをキャンセルしても、そのリクエストのブラウザリソースが解放されるだけであり、サーバーに到達するのを「追いついて」止めることはできません。ごくまれな状況では、中断する`action`の再検証が完了した後、キャンセルされたリクエストがデータを変更する可能性があります。この図を考えてみましょう:

```text
     👇 新しい送信による中断
|----❌----------------------✓
       |-------✓-----✅
                             👆
                  中断する送信の再検証が完了した後、
                  最初の要求がサーバーに到達する
```

ユーザーは現在、サーバー上のデータとは異なるデータを見ています。この問題は非常にまれであり、デフォルトのブラウザの動作でも存在することに注意してください。最初の要求が、2番目の送信と再検証の両方よりも遅れてサーバーに到達する可能性は、いかなるネットワークおよびサーバーインフラストラクチャにおいても予期せぬことです。これがインフラストラクチャの懸念事項である場合、フォーム送信にタイムスタンプを送信し、古い送信を無視するサーバーロジックを記述できます。

## 例

コンボボックスのようなUIコンポーネントでは、各キーストロークがネットワークリクエストをトリガーする可能性があります。このような高速で連続的なリクエストを管理することは、特に表示される結果が最新のクエリと一致することを保証する際に、厄介な場合があります。しかし、React Routerを使用すると、この課題は自動的に処理され、開発者がネットワークを細かく管理することなく、ユーザーが正しい結果を見ることができるようになります。

```tsx filename=app/pages/city-search.tsx
export async function loader({ request }) {
  const { searchParams } = new URL(request.url);
  const cities = await searchCities(searchParams.get("q"));
  return cities;
}

export function CitySearchCombobox() {
  const fetcher = useFetcher<typeof loader>();

  return (
    <fetcher.Form action="/city-search">
      <Combobox aria-label="Cities">
        <ComboboxInput
          name="q"
          onChange={(event) =>
            // submit the form onChange to get the list of cities
            fetcher.submit(event.target.form)
          }
        />

        {/* render with the loader's data */}
        {fetcher.data ? (
          <ComboboxPopover className="shadow-popup">
            {fetcher.data.length > 0 ? (
              <ComboboxList>
                {fetcher.data.map((city) => (
                  <ComboboxOption
                    key={city.id}
                    value={city.name}
                  />
                ))}
              </ComboboxList>
            ) : (
              <span>No results found</span>
            )}
          </ComboboxPopover>
        ) : null}
      </Combobox>
    </fetcher.Form>
  );
}
```

アプリケーションが知る必要があるのは、データのクエリ方法とレンダリング方法だけです。React Routerがネットワークを処理します。

## 結論

React Routerは、開発者にネットワークリクエストを管理するための直感的でブラウザベースのアプローチを提供します。ブラウザの動作を模倣し、必要に応じてそれを強化することで、同時実行、再検証、および潜在的な競合状態の複雑さを簡素化します。シンプルなウェブページを構築している場合でも、洗練されたウェブアプリケーションを構築している場合でも、React Routerはユーザーインタラクションがスムーズで信頼性が高く、常に最新であることを保証します。

[use_fetcher]: ../api/hooks/useFetcher