---
title: 競合状態
---

# 競合状態

アプリケーション内の起こりうるすべての競合状態を排除することは不可能ですが、React Router は Web ユーザーインターフェースでよく見られる競合状態のほとんどを自動的に処理します。

## ブラウザの動作

React Router のネットワーク並行処理は、ドキュメントを処理する際の Web ブラウザの動作に大きく影響を受けています。

新しいドキュメントへのリンクをクリックし、新しいページがロードを完了する前に別のリンクをクリックすることを考えてみてください。ブラウザは以下を行います。

1. 最初の要求をキャンセルする
2. 新しいナビゲーションをすぐに処理する

同じ動作はフォーム送信にも適用されます。保留中のフォーム送信が新しいフォーム送信によって中断された場合、最初のフォーム送信はキャンセルされ、新しいフォーム送信がすぐに処理されます。

## React Router の動作

ブラウザと同様に、リンクやフォーム送信による中断されたナビゲーションは、進行中のデータ要求をキャンセルし、新しいイベントをすぐに処理します。

フェッチャーはナビゲーションのような単一のイベントではないため、もう少しニュアンスがあります。フェッチャーは他のフェッチャーインスタンスを中断することはできませんが、自身を中断することはでき、動作は他のすべてと同じです。つまり、中断された要求をキャンセルし、新しい要求をすぐに処理します。

ただし、フェッチャーは再検証に関しては相互にやり取りします。フェッチャーのアクション要求がブラウザに返された後、すべてのページデータの再検証が送信されます。これは、複数の再検証要求が同時に進行中になる可能性があることを意味します。React Router はすべての「新しい」再検証応答をコミットし、古い要求をキャンセルします。古い要求とは、返された要求よりも「前に」開始された要求のことです。

このネットワーク管理により、ネットワーク競合状態によって引き起こされる最も一般的な UI バグを防ぐことができます。

ネットワークは予測不可能であり、サーバーは依然としてこれらのキャンセルされた要求を処理するため、バックエンドで競合状態が発生し、潜在的なデータ整合性の問題が発生する可能性があります。これらのリスクは、プレーン HTML の `<form>` でデフォルトのブラウザの動作を使用する場合と同じリスクであり、リスクは低いと考えられ、React Router の範囲外です。

## 実用的なメリット

タイプアヘッドコンボボックスの構築を考えてみましょう。ユーザーが入力すると、サーバーに要求が送信されます。ユーザーが新しい文字を入力するたびに、新しい要求が送信されます。テキストフィールドに存在しない値の結果をユーザーに表示しないことが重要です。

フェッチャーを使用すると、これは自動的に管理されます。この疑似コードを考えてみましょう。

```tsx
// route("/city-search", "./search-cities.ts")
export async function loader({ request }) {
  const { searchParams } = new URL(request.url);
  return searchCities(searchParams.get("q"));
}
```

```tsx
export function CitySearchCombobox() {
  const fetcher = useFetcher();

  return (
    <fetcher.Form action="/city-search">
      <Combobox aria-label="Cities">
        <ComboboxInput
          name="q"
          onChange={(event) =>
            // onChange でフォームを送信して都市のリストを取得する
            fetcher.submit(event.target.form)
          }
        />

        {fetcher.data ? (
          <ComboboxPopover className="shadow-popup">
            {fetcher.data.length > 0 ? (
              <ComboboxList>
                {fetcher.data.map((city) => (
                  <ComboboxOption
                    key={city.id}
                    value={city.name}
                  />
                ))}
              </ComboboxList>
            ) : (
              <span>No results found</span>
            )}
          </ComboboxPopover>
        ) : null}
      </Combobox>
    </fetcher.Form>
  );
}
```

`fetcher.submit` の呼び出しは、そのフェッチャーの保留中の要求を自動的にキャンセルします。これにより、異なる入力値に対する要求の結果がユーザーに表示されることはありません。

